# 拷贝控制

## 拷贝、赋值与销毁

### 拷贝构造函数

如果一个构造函数的第一个参数是**自身类类型的引用**，且**任何额外参数都有默认值**，则此构造函数是拷贝构造函数。

```c++
class Foo {
public:
    Foo();  // 默认构造函数
    Foo(const Foo &);  // 拷贝构造函数。可以非const，但几乎总是使用const引用。
}
```

* 拷贝构造函数在几种情况下会被隐式地使用。因此，拷贝构造函数通常不应该是 explicit 的。
* 编译器可以（但不是必须）跳过拷贝/移动构造函数，直接创建对象。P442

#### 合成拷贝构造函数

如果我们没有为一个类定义拷贝构造函数，编译器会为我们定义一个。合成的拷贝构造函数会将其参数的成员逐个拷贝到正在创建的对象中。

对某些类来说，合成拷贝构造函数用来阻止我们拷贝该类类型的对象。

对类类型的成员，会使用其拷贝构造函数来拷贝；内置类型的成员则直接拷贝。对于数组成员，合成拷贝构造函数会逐元素地拷贝一个数组类型的成员。

#### 拷贝初始化

拷贝初始化是依靠拷贝构造函数或移动构造函数来完成的。

##### 拷贝初始化发生场景

* 用 = 定义变量
* 将一个对象作为实参传递给一个非引用类型的形参
* 从一个返回类型为非引用类型的函数返回一个对象
* 用花括号列表初始化一个数组中的元素或一个聚合类中的成员

* 某些类类型还会对它们所分配的对象使用拷贝初始化（例如：初始化标准库容器或是调用其 insert 或 push 成员）

### 拷贝赋值运算符

```c++
class Foo {
public:
    Foo& operator=(const &Foo);  // 赋值运算符
}
```

* 赋值运算符通常应该返回一个指向其左侧运算对象的引用。

#### 合成拷贝赋值运算符

如果我们没有为一个类定义拷贝赋值运算符，编译器会为我们生成一个合成拷贝赋值运算符。

对于某些类，合成拷贝赋值运算符用来禁止该类型对象的赋值。

右侧运算对象的每个非 static 成员赋予左侧运算对象的对应成员，这一工作是通过成员类型的拷贝赋值运算符来完成的。对于数组类型的成员，逐个赋值数组元素。

### 析构函数

析构函数释放对象使用的资源，并销毁对象的非 static 数据成员。

析构函数是类的一个成员函数，名字由波浪号接类名构成。它没有返回值，也不接受参数。

```c++
class Foo {
public:
    ~Foo();  // 析构函数
}
```

由于析构函数不接受参数，因此它不能被重载。对一个给定类，只会有唯一一个析构函数。

#### 析构函数完成什么工作

析构函数有一个函数体和一个析构部分。在一个析构函数中，首先执行函数体，然后销毁成员。成员按初始换顺序的逆序销毁。析构部分是隐式的。

* 隐式销毁一个内置指针类型的成员不会 delete 它所指向的对象。
* 智能指针是类类型，所以具有析构函数。智能指针成员在析构阶段会被自动销毁。

#### 什么时候会调用析构函数

无论何时一个对象被销毁，就会自动调用其析构函数：

* 变量在离开其作用域时被销毁。
* 当一个对象被销毁时，其成员被销毁。
* 容器（无论是标准库容器还是数组）被销毁时，其元素被销毁。
* 对于动态分配的对象，当对指向它的指针应用 delete 运算符时被销毁。
* 对于临时对象，当创建它的完整表达式结束时被销毁。

当指向一个对象的引用或指针离开作用域时，析构函数不会执行。（需要手动 delete）

#### 合成析构函数

当一个类未定义自己的构造函数时，编译器会为它定义一个合成析构函数。合成析构函数的函数体为空。

对于某些类，合成析构函数被用来阻止该类型的对象被销毁。