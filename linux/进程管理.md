# 进程管理

从内核看，进程是分配系统资源（CPU、内存）的载体，为了管理进程，内核必须对每个进程所做的事情进行清楚的描述，这就是进程描述符，内核用 task_struct 结构体来表示进程，并且维护一个该结构体链表来管理所有进程。该结构体包含一些进程状态、调度信息等上千个成员，我们这里主要关注进程描述符里面的内存描述符（struct mm_struct mm）



## 进程调度

> [linux进程调度浅析](https://blog.csdn.net/ctthuangcheng/article/details/8914309)
>
> [浅析Linux内核调度](https://www.cnblogs.com/wangzahngjun/p/4911432.html)

### CFS 完全公平调度算法

> [linux内核cfs浅析](https://blog.csdn.net/ctthuangcheng/article/details/8916071)
>
> [linux内核分析——CFS（完全公平调度算法）](https://www.cnblogs.com/tianguiyu/articles/6091378.html)

#### 数据结构

##### vruntime 虚拟时钟

##### sched_entity 调度实体

调度实体 sched_entity 代表一个调度单位，在组调度关闭的时候可以把它等同为进程。

每一个 task_struct 中都有一个 sched_entity，进程的vruntime和权重都保存在这个结构中。所有的sched_entity通过**红黑树**组织在一起。所有的 sched_entity 以 vruntime 为key(实际上是以 vruntime-min_vruntime 为 key ，是为了防止溢出，反正结果是一样的)插入到红黑树中，同时缓存树的最左侧节点，也就是 vruntime 最小的节点，这样可以迅速选中 vruntime 最小的进程。

注意只有等待CPU的就绪态进程在这棵树上，睡眠进程和正在运行的进程都不在树上。

### FIFO / RR

> [Linux进程管理 (9)实时调度类分析，以及FIFO和RR对比实验](https://www.cnblogs.com/arnoldlu/p/9025981.html)
>
> [linux内核的三种主要调度策略](https://blog.csdn.net/xhz_1983/article/details/78294934)



## idle

* idle是一个进程，其pid为0。  
* 主处理器上的idle由原始进程(pid=0)演变而来。从处理器上的idle由init进程fork得到，可是它们的pid都为0。  
* Idle进程为最低优先级。且不參与调度。仅仅是在执行队列为空的时候才被调度。  
* Idle循环等待need_resched置位。默认使用hlt节能。



## 组调度 cgroup

> [linux组调度浅析](https://blog.csdn.net/ctthuangcheng/article/details/8914825)

cpu.shares