# 内存管理

## To-Do

[内存管理笔记十、buddy伙伴系统](https://blog.csdn.net/XD_hebuters/article/details/79519406)

[内存管理（一）node & zone](http://blog.chinaunix.net/uid-30282771-id-5171166.html)

[内核必须懂(五): per-CPU变量](https://www.jianshu.com/p/f67517b3a150)

分页和分段

内存映射

[linux内存源码分析 - 伙伴系统(初始化和申请页框)](https://www.cnblogs.com/tolimit/p/4610974.html)

***

## 结构

### 内存节点 Node

​		每个CPU都有自己的本地内存节点（memory node），而且还可以通过QPI总线访问其他CPU下挂的内存节点，只是访问本地内存要比访问其他CPU下的内存的速度高许多，一般经过一次QPI要增加30%的访问时延。

### 内存域 Zone

​		 由于一些特殊的应用场景，导致只能分配特定地址范围内的内存（比如老式的ISA设备DMA时只能使用前16M内存；比如kmalloc只能分配低端内存，而不能分配高端内存），因此在node中又将内存细分为zone。

* **ZONE_DMA**：定义适合DMA的内存域，该区域的长度依赖于处理器类型。比如ARM所有地址都可以进行DMA，所以该值可以很大，或者干脆不定义DMA类型的内存域。而在IA-32的处理器上，一般定义为16M。
* **ZONE_DMA32**：只在64位系统上有效，为一些32位外设DMA时分配内存。如果物理内存大于4G，该值为4G，否则与实际的物理内存大小相同。
* **ZONE_NORMAL**：定义可直接映射到内核空间的普通内存域。在64位系统上，如果物理内存小于4G，该内存域为空。而在32位系统上，该值最大为896M。
* **ZONE_HIGHMEM**：只在32位系统上有效，标记超过896M范围的内存。在64位系统上，由于地址空间巨大，超过4G的内存都分布在ZONE_NORMA内存域。
* **ZONE_MOVABLE**：伪内存域，为了实现减小内存碎片的机制。

### 页 Page

​		因为内核会为每一个物理页帧创建一个struct page的结构体，因此要保证page结构体足够的小，否则仅struct page就要占用大量的内存。出于节省内存的考虑，struct page中使用了大量的联合体union。

> [内存管理（二）struct page](http://blog.chinaunix.net/uid-30282771-id-5176971.html)

​		`_count`和`_mapcount`，`_mapcount`表示的是映射次数，而`_count`表示的是使用次数；**被映射了不一定在使用，但要使用必须先映射。**



## 反碎片化

> [内存管理（三）内存的反碎片技术-伙伴系统&内存分类](http://blog.chinaunix.net/uid-30282771-id-5185451.html)

### 伙伴系统 Buddy

​		在实际应用中，经常需要分配一组连续的页框，而频繁地申请和释放不同大小的连续页框，必然导致在已分配页框的内存块中分散了许多小块的空闲页框。这样，即使这些页框是空闲的，其他需要分配连续页框的应用也很难得到满足。
​		为了避免出现这种情况，Linux内核中引入了伙伴系统算法(buddy system)。把所有的空闲页框分组为11个块[链表](https://baike.baidu.com/item/链表/9794473)，每个块链表分别包含大小为1，2，4，8，16，32，64，128，256，512和1024个连续页框的页框块。最大可以申请1024个连续页框，对应4MB大小的连续内存。每个[页框](https://baike.baidu.com/item/页框)块的第一个页框的物理地址是该块大小的整数倍。
​		假设要申请一个256个页框的块，先从256个页框的链表中查找空闲块，如果没有，就去512个页框的链表中找，找到了则将页框块分为2个256个页框的块，一个分配给应用，另外一个移到256个页框的链表中。如果512个页框的链表中仍没有空闲块，继续向1024个页框的链表查找，如果仍然没有，则返回错误。
​		页框块在释放时，会主动将两个连续的页框块合并为一个较大的页框块。

> [内存管理笔记十、buddy伙伴系统](https://blog.csdn.net/XD_hebuters/article/details/79519406)

### 内存分类

Linux中使用的内存大体可分为以下三类：
* 不可移动页：在内存中的位置固定，不能移动到其他地方。内核分配的内存都属于这种类型。
* 可回收页：不能直接移动，但可以删除，因为其内容可从某些源重新生成，如文件映射产生的页。
* 可移动页：在内存中的位置可随便移动，只要修改其对应的页表即可。用户态应用程序使用的页属于这种类型。

### slab (分配小块内存)

​		slab是Linux操作系统的一种内存分配机制。其工作是针对一些经常分配并释放的对象，如进程描述符等，这些对象的大小一般比较小，如果直接采用伙伴系统来进行分配和释放，不仅会造成大量的内存碎片，而且处理速度也太慢。而slab分配器是基于对象进行管理的，相同类型的对象归为一类(如进程描述符就是一类)，每当要申请这样一个对象，slab分配器就从一个slab列表中分配一个这样大小的单元出去，而当要释放时，将其重新保存在该列表中，而不是直接返回给伙伴系统，从而避免这些内碎片。slab分配器并不丢弃已分配的对象，而是释放并把它们保存在内存中。当以后又要请求新的对象时，就可以从内存直接获取而不用重复初始化。



## Other

### 内存分配掩码 gfp_mask

​		内存分配掩码包括两部分，内存域修饰符（占低4位）和内存分配标志（从第5位开始）

> [内存管理（四）内存分配掩码（gfp_mask） - 内存域修饰符 & 内存分配标志](http://blog.chinaunix.net/uid-30282771-id-5191401.html)

### per-CPU

​		per-CPU变量是linux系统一个非常有趣的特性，它为系统中的每个处理器都分配了该变量的副本。这样做的好处是，在多处理器系统中，当处理器操作属于它的变量副本时，不需要考虑与其他处理器的竞争的问题，同时该副本还可以充分利用处理器本地的硬件缓冲cache来提供访问速度。

​		per-CPU按照存储变量的空间来源分为静态per-CPU变量和动态per-CPU变量，前者的存储空间是在代码编译时静态分配的，而后者的存储空间则是在代码的执行期间动态分配的。

> [per-CPU变量](https://www.cnblogs.com/linhaostudy/p/10342667.html)



#### cached地址和uncached地址的区别

> [cached地址和uncached地址的区别](https://blog.csdn.net/linuxandroidwince/article/details/7638318)
